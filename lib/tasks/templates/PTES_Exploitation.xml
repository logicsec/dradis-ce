<?xml version="1.0"?>
<methodology>
	<name>PTES Exploitation</name>
	<sections>
		<section>
			<name>Precision Strike</name>
			<tasks>
				<task>Exploitation: Precision Strike. Additional information on exploitation can be found at the Metasploit Unleashed course.</task>
				<task>Countermeasure Bypass: AV. Encoding, Packing, Whitelist bypass, process injection, purely memory resident.</task>
				<task>Countermeasure Bypass: Human.</task>
				<task>Countermeasure Bypass: HIPS</task>
				<task>Countermeasure Bypass: DEP</task>
				<task>Countermeasure Bypass: A SLR</task>
				<task>Countermeasure Bypass: VA + NX (Linux)</task>
				<task>Countermeasure Bypass: w^x (OpenBSD)</task>
				<task>Countermeasure Bypass: WAF. A WAF (Web application firewall) is a firewall which can be installed in front of (network topology speaking) a web application. The WAF will analyze each request and look for common web attacks such as Cross Site Scripting and SQLinjection. Like most AV scanners, a blacklisting mechanism is often used to find these potentially malicious HTTP requests (often regex). Since these WAFs are using this blacklisting technique, multiple papers exist on bypassing these types of devices.</task>
				<task>Countermeasure Bypass: Stack Canaries. A buffer overflow happens when an application fails to properly verify the length of the input received with the length of the buffer in memory to which this data is copied. A "cookie" or stack canary is added right after the buffer on the stack. When the application wants to return, the value of the stack canary is verified. If this value has been altered, the program will ignore the EIP and crash therefore making the buffer overflow ineffective. Every operating system calculates a different cookie. The cookie in Windows is added by Visual Studio. In Linux the somewhat default compiler, gcc, adds the code for the stack canarie. This code can be found in the file libssp/ssp.c. In MAC OC, the stack canary is disabled by default.</task>
			</tasks>
		</section>
		<section>
			<name>Customized Exploitation</name>
			<tasks>
				<task>Dumb Fuzzing: This usually consists of simple modifications to legitimate data, that is then fed to the target application. In this case, the fuzzer is very easy to write and the idea is to identify low hanging fruit. Although not an elegant approach, dumb fuzzing can produce results, especially when a target application has not been previously tested. FileFuzz is an example of a Dumb Fuzzer.</task>
				<task>Intelligent Fuzzing: Intelligent Fuzzers are ones that are generally aware of the protocol or format of the data being tested. Some protocols require that the fuzzer maintain state information, such as HTTP or SIP. Other protocols will make use of authentication before a vulnerability is identified. Apart from providing much more code coverage, intelligent fuzzers tend to cut down the fuzzing time significantly since they avoid sending data that the target application will not understand. Intelligent fuzzers are therefore much more targeted and sometimes they need to be developed by the security researcher.</task>
				<task>Sniffing: A packet analyzer is used to intercept and log traffic passing over the network. It is considered best practice to utilize a sniffer when performing exploitation. This ensures that all relevant traffic is captured for further analysis. This is also extremely useful for extracting cleartext passwords. Common tools usef for this task include Wireshark and Tcpdump.</task>
				<task>Brute Force: systematically check all possible usernames and passwords until the correct one is found. Common tools used for this task include Brutus (Windows), Web Brute (Windows), THC-Hydra/XHydra, Medusa, and Ncrack.</task>
				<task>Routing Protocols: these specify how routers communicate with each other, disseminating information that enables them to select routes between any two nodes on a computer network, the choice of the route being done by routing algorithms. Each router has a priori knowledge only of networks attached to it directly. A routing protocol shares this information first among immediate neighbors, and then throughout the network. This way, routers gain knowledge of the topology of the network.</task>
				<task>Cisco Discovery Protocol (CDP): The information contained in CDP announcements varies by the type of device and the version of the operating system running on it. This information may include the operating system version, hostname, every address (i.e. IP address) from all protocol(s) configured on the port where CDP frame is sent, the port identifier from which the announcement was sent, device type and model, duplex setting, VTP domain, native VLAN, power draw (for Power over Ethernet devices), and other device specific information. The details contained in these announcements are easily extended due to the use of the type-length-value (TLV) frame format. The tool for attacking CDP is Yersinia.</task>
				<task>Hot Standby Router Protocol (HSRP): This is a Cisco proprietary redundancy protocol for establishing a fault-tolerant default gateway, and has been described in detail in RFC 2281. The Virtual Router Redundancy Protocol (VRRP) is a standards-based alternative to HSRP defined in IETF standard RFC 3768. The two technologies are similar in concept, but not compatible. The tool for attacking HSRP is Yersinia.</task>
				<task>Virtual Switch Redundancy Protocol (VSRP): This is a proprietary network resilience protocol developed by Foundry Networks and currently being sold in products manufactured by both Foundry and Hewlett Packard. The protocol differs from many others in use as it combines Layer 2 and Layer 3 resilience - effectively doing the jobs of both Spanning tree protocol and the Virtual Router Redundancy Protocol at the same time. Whilst the restrictions on the physical topologies able to make use of VSRP mean that it is less flexible than STP and VRRP it does significantly improve on the failover times provided by either of those protocols.</task>
				<task>Dynamic Trunking Protocol (DTP): This is a proprietary networking protocol developed by Cisco Systems for the purpose of negotiating trunking on a link between two VLAN-aware switches, and for negotiating the type of trunking encapsulation to be used. It works on the Layer 2 of the OSI model. VLAN trunks formed using DTP may utilize either IEEE 802.1Q or Cisco ISL trunking protocols. DTP should not be confused with VTP, as they serve different purposes. VTP communicates VLAN existence information between switches. DTP aids with trunk port establishment. Neither protocol transmits the data frames that trunks carry. The tool for attacking DTP is Yersinia.</task>
				<task>Spanning Tree Protocol (STP): The Spanning Tree Protocol (STP) is a network protocol that ensures a loop-free topology for any bridged Ethernet local area network. The basic function of STP is to prevent bridge loops and ensuing broadcast radiation. STP is a Data Link Layer protocol. It is standardized as IEEE 802.1D. As the name suggests, it creates a spanning tree within a mesh network of connected layer-2 bridges (typically Ethernet switches), and disables those links that are not part of the spanning tree, leaving a single active path between any two network nodes. The tool for attacking STP is Yersinia.</task>
				<task>Open Shortest Path First (OSPF): This is an adaptive routing protocol for Internet Protocol (IP) networks. It uses a link state routing algorithm and falls into the group of interior routing protocols, operating within a single autonomous system (AS). It is defined as OSPF Version 2 in RFC 2328 (1998) for IPv4. The updates for IPv6 are specified as OSPF Version 3 in RFC 5340 (2008).</task>
				<task>RIP: This is a dynamic routing protocol used in local and wide area networks. As such it is classified as an interior gateway protocol (IGP). It uses the distance-vector routing algorithm. It was first defined in RFC 1058 (1988). The protocol has since been extended several times, resulting in RIP Version 2 (RFC 2453). Both versions are still in use today, although they are considered to have been made technically obsolete by more advanced techniques such as Open Shortest Path First (OSPF) and the OSI protocol IS-IS. RIP has also been adapted for use in IPv6 networks, a standard known as RIPng (RIP next generation) protocol, published in RFC 2080 (1997).</task>
				<task>VLAN Hopping - Switch Spoofing: In this attack, an attacking host that is capable of speaking the tagging and trunking protocols used in maintaining a VLAN imitates a trunking switch. Traffic for multiple VLANs is then accessible to the attacking host.</task>
				<task>VLAN Hopping - double tagging attack: In this attack, an attacking host prepends two VLAN tags to packets that it transmits. The first header (which corresponds to the VLAN that the attacker is really a member of) is stripped off by a first switch the packet encounters, and the packet is then forwarded. The second, false, header is then visible to the second switch that the packet encounters. This false VLAN header indicates that the packet is destined for a host on a second, target VLAN. The packet is then sent to the target host as though it were layer 2 traffic. By this method, the attacking host can bypass layer 3 security measures that are used to logically isolate hosts from one another. The tool for attacking 802.1q is Yersinia.</task>
				<task>VLAN Trunking Protocol (VTP): This is a Cisco proprietary Layer 2 messaging protocol that manages the addition, deletion, and renaming of Virtual Local Area Networks (VLAN) on a network-wide basis. Cisco's VLAN Trunk Protocol reduces administration in a switched network. When a new VLAN is configured on one VTP server, the VLAN is distributed through all switches in the domain. This reduces the need to configure the same VLAN everywhere. To do this, VTP carries VLAN information to all the switches in a VTP domain. VTP advertisements can be sent over ISL, 802.1q, IEEE 802.10 and LANE trunks. VTP is available on most of the Cisco Catalyst Family products. The tool for attacking VTP is Yersinia.</task>
			</tasks>
		</section>
		<section>
			<name>RF Access</name>
			<tasks>
				<task>Unencrypted Wireless LAN: It is possible to actually connect to an unencrypted Wireless LAN (WLAN). To connect to an unencrypted WLAN, you simply have to either issue appropriate commands or use a GUI interface to connect. Common tools used for this task include Iwconfig (Linux)</task>
				<task>Windows: Based upon the wireless network adapter installed, Windows will provide you with a mechanism to connect to wireless networks. The version of Windows utilized will dictate the process.</task>
				<task>Attacking the access point: All identified access points are vulnerable to numerous attacks. For completeness, we've included some attack methods that may not be a part of all engagements. Ensure that the scoping is reviewed prior to initiating any attacks.</task>
				<task>Denial of Service (DoS) - CTS: The first technique is to transmit the Clear to Send (CTS) packets, meaning that anyone in range of your signal will be unable to transmit. This requires a high-gain Omni-directional antenna to a much greater impact. Generally speaking, transmitting the CTS has a greater impact.</task>
				<task>Denial of Service (DoS) - RTS: The second technique is to send a Request to Send (RTS) packet to the AP you are targeting. Once the AP gets the RTS packet, it will send the CTS. A highly directional antenna from a distance can be used to target the AP with an RTS packet.</task>
				<task>Cracking Passwords - WPA-PSK/ WPA2-PSK: WPA-PSK is vulnerable to brute force attack. Tools like Aircrack and coWPAtty take advantage of this weakness and provided a way to test keys against dictionaries. Precomputational attacks are limited as the BSSID and the BSSID length are seeded into the passphrase hash so WPA-PSK attacks are generally limited due by time. There is no difference between cracking WPA or WPA2, the authentication is essentially the same. The main requirement for any WPA/WPA2 is to capture the authentication handshake and then use Aircrack-ng to crack the pre-shared key. This can be done either actively (by deauthenticating an existing wireless client) or passively (simply wait for a wireless client to authenticate to the WPA/WPA2 network).</task>
				<task>Cracking Passwords - WPA/WPA2-Enterprise: In environments with a large number of users, such as corporations or universities, WPA/WPA2 pre-shared key management is not feasible. Therefore WPA2 Enterprise authenticates users against a user database (RADIUS). Two common methods to do that are WPA2-EAP-TTLS and WPA2-PEAP.</task>
				<task>LEAP (Lightweight Extensible Authentication Protocol): This protocol is based on 802.1X and helps minimize the original security flaws by using WEP and a sophisticated key management system. This EAP-version is safer than EAP-MD5. This also uses MAC address authentication. LEAP is not safe against crackers. THC-LeapCracker can be used to break Cisco's version of LEAP and be used against computers connected to an access point in the form of a dictionary attack. Anwrap and asleap are other crackers capable of breaking LEAP.</task>
				<task>802.1X Attack - Key Distribution Attack: The key distribution attack exploits a weakness in the RADIUS protocol. The key distribution attack relies on an attacker capturing the PMK transmission between the RADIUS server and the AP. As the PMK is transmitted outside of the TLS tunnel, its protection is solely reliant on the RADIUS server's HMAC-MD5 hashing algorithm. Should an attacker be able to leverage a man-in-the-middle attack between the AP and RADIUS sever, a brute-force attempt could be made to crack the RADIUS shared secret. This would ultimately provide the attacker with access to the PMK - allowing full decryption of all traffic between the AP and supplicant.</task>
				<task>802.1X Attack - RADIUS Impersonation Attack: The RADIUS impersonation attack relies on users being left with the decision to trust or reject certificates from the authenticator. Attackers can exploit this deployment weakness by impersonating the target network's AP service set identifier (SSID) and RADIUS server. Once both the RADIUS server and AP have been impersonated the attacker can issue a 'fake' certificate to the authenticating user. After the certificate has been accepted by the user the client will proceed to authenticate via the inner authentication mechanism. This allows the attacker to capture the MSCHAPv2 challenge/response and attempt to crack it offline.</task>
				<task>PEAP Attack - RADIUS Impersonation Attack: The RADIUS impersonation attack relies on users being left with the decision to trust or reject certificates from the authenticator. Attackers can exploit this deployment weakness by impersonating the target network's AP service set identifier (SSID) and RADIUS server. Once both the RADIUS server and AP have been impersonated the attacker can issue a 'fake' certificate to the authenticating user. After the certificate has been accepted by the user the client will proceed to authenticate via the inner authentication mechanism. This allows the attacker to capture the MSCHAPv2 challenge/response and attempt to crack it offline.</task>
				<task>PEAP Attack - Authentication Attack: The PEAP authentication attack is a primitive means of gaining unauthorized access to PEAP networks. By sniffing usernames from the initial (unprotected) PEAP identity exchange an attacker can attempt to authenticate to the target network by 'guessing' user passwords. This attack is often ineffective as the authenticator will silently ignores bad login attempts ensuring a several second delay exists between login attempts. </task>
				<task>EAP-FAST (Flexible Authentication via Secure Tunneling): This is Cisco's replacement for LEAP. The protocol was designed to address the weaknesses of LEAP while preserving the "lightweight" implementation. EAP-FAST uses a Protected Access Credential (PAC) to establish a TLS tunnel in which client credentials are verified. EAP-FAST provides better protection against dictionary attacks, but is vulnerable to MITM attacks. Since many implementations of EAP-FAST leave anonymous provisioning enabled, AP impersonation can reveal weak credential exchanges.</task>
				<task>WEP/WPA/WPA2: The core process of connecting to a WEP encrypted network revolves around obtaining the WEP key for the purpose of connecting to the network. There are several tools that can be used to perform attacks against WEP.</task>
				<task>Aircrack-ng: Aircrack-ng is an 802.11 WEP and WPA/WPA2-PSK key cracking program. Aircrack-ng can recover the WEP key once enough encrypted packets have been captured with airodump-ng. This part of the Aircrack-ng suite determines the WEP key using two fundamental methods. The first method is via the PTW approach (Pyshkin, Tews, and Weinmann). The default cracking method is PTW.For cracking WPA/WPA2 pre-shared keys, only a dictionary method is used. SSE2 support is included to dramatically speed up WPA/WPA2 key processing. A "four-way handshake" is required as input. For WPA handshakes, a full handshake is composed of four packets. However, Aircrack-ng is able to work successfully with just 2 packets. EAPOL packets (2 and 3) or packets (3 and 4) are considered a full handshake.</task>
				<task>Aircrack-ng Attack - Fake authentication: The fake authentication attack allows you to perform the two types of WEP authentication (Open System and Shared Key) and to associate with an AP. This attack is useful in scenarios where there are no associated clients. Note that fake authentication attacks do not generate ARP packets.</task>
				<task>Aircrack-ng Attack - ARP Request Replay Attack: The classic ARP request replay attack is the most effective way to generate new initialization vectors. This attack is probably the most reliable of all. The program listens for an ARP packet then retransmits it back to the AP. This, in turn causes the AP to repeat the ARP packet with a new IV. The program retransmits the same ARP packet over and over. However, each ARP packet repeated by the AP has a new IV. The collection of these IVs will later help us later in determining the WEP key.</task>
				<task>Aircrack-ng Attack - KoreK chopchop: The KoreK chopchop attack can decrypt a WEP data packet without knowing the key. It can even work against dynamic WEP. This attack does not recover the WEP key itself, it merely reveals the plaintext. Some APs are not vulnerable to this attack. They may seem vulnerable at first but actually drop data packets shorter than 60 bytes. If the AP drops packets shorter than 42 bytes, Aireplay tries to guess the rest of the missing data, as far as the headers are predictable. If an IP packet is captured Aireplay checks if the checksum of the header is correct after guessing its missing parts. Remember that this attack requires at least one WEP data packet.</task>
				<task>Aircrack-ng Attack - Fragmentation Attack: The fragmentation attack does not recover the WEP key itself, but (also) obtains the PRGA (pseudo random generation algorithm) of the packet. The PRGA can then be used to generate packets with Packetforge-ng which are in turn are used for various injection attacks. The attack requires at least one data packet to be received from the AP in order to initiate the attack. Basically, the program obtains a small amount of keying material from the packet then attempts to send ARP and/or LLC packets with known content to the AP. If the packet is successfully echoed back by the AP then a larger amount of keying information can be obtained from the returned packet. This cycle is repeated several times until 1500 bytes of PRGA are obtained (sometimes less than 1500 bytes).</task>
				<task>Aircrack-ng Attack - Injection test: The injection test determines if your card can successfully inject wireless packets, and measures ping response times to APs. If you have two wireless cards connected, the test can also determine which specific injection attacks can be successfully executed. The basic injection test lists the APs in the area which respond to broadcast probes, and for each it performs a 30 packet test which measures the connection quality. This connection quality quantifies the ability of your card to successfully send and receive a response to the test target. The percentage of responses received gives a good indication of the link quality.</task>
			</tasks>
		</section>
		<section>
			<name>Attacking the User</name>
			<tasks>
				<task>Attacking the user: The Rules of Engagment (ROE) should be validated to ensure this is in-scope before conducting any attacks against the users</task>
				<task>Attacking the User - Karmetasploit Attacks: Karmetasploit is a modification of the KARMA to integrate it into Metasploit. Karmetasploit creates a working "evil" access point working that provides network services to an unsuspecting user. The services Karmetasploit provides include a DNS daemon that responds to all requests, a POP3 service, an IMAP4 service, a SMTP service, a FTP service, a couple of different SMB services, and a web service. All DNS lookups result in the IP address of the access point being returned, resulting in a blackhole effect for all email, web, and other network traffic.</task>
				<task>Attacking the User - DNS Requests</task>
				<task>Attacking the User - Bluetooth</task>
				<task>Attacking the User - Personalized Rogue AP. DoS / Blackmail angle.</task>
				<task>Web Application: In the quest to find all the entry points, during the intelligence gathering and vulnerability analysis phase the penetration tester will utilize mostly GET and POST requests but should also test head, put, delete, trace, options, connect and patch. The objective is to map all input and output points. These are not limited to simply forms on a page, but include cookies, links, hidden forms, http parameters, etc. During the exploration particular attention should be given to sessions, cookies, error pages, http status codes, indirectly accessible pages, encryption usage and server configuration, dns and proxy cache usage. Ideally, this will be done using both automated and manual methods to discover potential ways to manipulate the web application parameters or logic. This is generally done using some form of client application (browser) and a proxy that can sit between the client application and the web application, and a tool to crawl (aka spider) through page links.</task>
				<task>Web Application - SQL Injection: SQLi, consists of insertion or "injection" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system and in some cases issue commands to the operating system. SQL injection attacks are a type of injection attack, in which SQL commands are injected into data-plane input in order to effect the execution of predefined SQL commands. One possible way to test for sql injection is to enter a ' into input fields then compare the application response to a well formed request. If the web application is vulnerable to SQLi, a ' may return different results when the SQL statement attempts to execute. Was an error message returned, different results, web page a different size, are different HTTP codes returned. Don't forget to look at the source, not just what is displayed in the browser. Depending on the reaction, it may be necessary to use other tests for injection, for example " or '; or ) or '+"=' or %27%20or%201=1. It may also be necessary to encode the characters to bypass filters. If the access to the source code of the application is available, review for any variables where input can be manipulated as part of the application usage. In some cases this will be readily apparent, for instance php $sql = "SELECT * from [table] WHERE tuple = '$_GET("input"]'";	c# $sql = "SELECT * from [table] WHERE tuple = '" + request.getParameter("input") = "'";. Tools available for this task include Havij, SQLmap, The Mole, and Pangolin.</task>
				<task>Web Application - XSS</task>
				<task>Web Application - CSRF</task>
				<task>Ad-hoc Networks: Information Leakage</task>
				<task>Detection Bypass: FW/WAF/IDS/IPS Evasion, Human Evasion, DLP Evasion</task>
				<task>Resistance of Controls to attacks</task>
				<task>Type of Attack: Client Side, Phishing (w/pretext), Service Side, Out of band, Post-Exploitation, Infrastructure analysis</task>
				<task>The Social-Engineer Toolkit (SET): This is a python-driven suite of custom tools which solely focuses on attacking the human element of pentesting. Itâ€™s main purpose is to augment and simulate social-engineering attacks and allow the tester to effectively test how a targeted attack may succeed. Currently SET has two main methods of attack, one is utilizing Metasploit payloads and Java-based attacks by setting up a malicious website (which you can clone whatever one you want) that ultimately delivers your payload. The second method is through file-format bugs and e-mail phishing. The second method supports your own open-mail relay, a customized sendmail open-relay, or Gmail integration to deliver your payloads through e-mail. </task>
			</tasks>
		</section>
		<section>
			<name>VPN Detection</name>
			<tasks>
				<task>VPN Hunter: (http://www.vpnhunter.com) discovers and classifies SSL VPNs from top vendors including Juniper, Cisco, Palo Alto, Citrix, Fortinet, F5, SonicWALL, Barracuda, Microsoft, and Array. VPN Hunter will also attempt to detect whether two-factor authentication is enabled on the target SSL VPNs.</task>
			</tasks>
		</section>
		<section>
			<name>Route Detection, including static routes</name>
			<tasks>
				<task>Network protocols in use</task>
				<task>Proxies in use: Network level, application level, </task>
				<task>Network layout: Mapping connectivity in/out of every segment, Lateral connectivity</task>
				<task>High value/profile targets</task>
			</tasks>
		</section>
		<section>
			<name>Pillaging</name>
			<tasks>
				<task>Pillaging - Video Cameras</task>
				<task>Pillaging - Data Exfiltration: identify web servers, identify ftp servers, DNS and ICMP tunnels, VoIP channels, Physical channels (printing, garbage disposal, courier), Fax (on multifunction printers)</task>
				<task>Pillaging - Locating Shares</task>
				<task>Pillaging - Audio Capture: VoIP, Microphone</task>
				<task>Pillaging - High Value Files</task>
				<task>Pillaging - Database Enumeration: Checking for PPI, card data, passwords/user accounts.</task>
				<task>Pillaging - Wifi: Steal wifi keys, Add new Wifi entries with higher preference then setup AP to force connection, Check ESSIDs to identify places visited</task>
				<task>Pillaging - Source Code Repos: SVN, CVS, MS Sourcesafe, WebDAV</task>
				<task>Pillaging - Git: Git is often used to deploy web applications and the .git meta directory is sometimes available to pillage. One quick way to find the repo is to look for the file http://example.com/.git/HEAD and see if it contains a match to ^ref: refs/ W3AF (http://w3af.sourceforge.net/) contains a discovery plugin named findGit.py that will assist in finding git repositories of web targets. Note: the .git directory is not always present in the root, but sometimes in sub directories depending on how a part of the application is deployed. Something like http://example.com/blog/.git/. If possible, clone the repo or check for directory browsing. Files with predictables names can contain useful infornation: .git/index, .git/config, .git/logs/HEAD, .git/hooks/*</task>
				<task>Pillaging - Identigy custom apps</task>
				<task>Pillaging - Backups: Locally stored backup files, Central backup server, Remote backup solutions, Tape storage</task>
			</tasks>
		</section>
		<section>
			<name>Business Impact Attacks</name>
			<tasks>
				<task>Business impact attacks: What makes the business money? Steal it!</task>
			</tasks>
		</section>Further Penetration in to infrastructure<section>
			<name></name>
			<tasks>
				<task>Further Penetration into Infrastructure: Botnets, Windows Commands, Token Stealing and Reuse, Password Cracking, Wifi connections to other devices, Password Reuse, Keyloggers, User enumeration, From Windows DC or from individual machines, Linux passwd file, MSSQL Windows Auth users</task>
				<task>Linux commands: Show users that have used ssh to connect to this host. grep publickey /var/log/secure*|awk '{print $9"\t"$11"\t"$NF}'|sort -u</task>
				<task>Linux commands: Show users that have used sudo. grep sudo /var/log/secure*|awk -F: '{print $4}'|sort -u</task>
				<task>Linux commands: Show users with active cron use. cat /var/log/cron* |awk '$6 !~ /Updated/ {print $6}'|tr -d \(\)|sort -u</task>
				<task>Linux commands: Look at a users password settings. passwd -S user</task>
				<task>Linux commands: Users that have connected and from where. for i in $(ls /var/log/wtmp*);do last -adf ${i}|awk '$1 !~ /wtmp/ {print $1,$NF}'|sort -u; done</task>
				<task>Linux commands: Who is logged in right now and from where. $ who -Hu NAME LINE TIME IDLE PID COMMENT user1 pts/0 Jun 2 10:39 . 28001 (testhost.example.com)</task>
				<task>Linux commands: Pull IPv4 hosts from /etc/hosts, drop commented entries and localhost. egrep -v "^[ \t]*#|^[ \t]*$|localhost" /etc/hosts 10.0.0.1 testhost.example.com testhost 10.0.0.2 testhost2.example.com testhost2 10.0.0.3 testhost3.example.com testhost3</task>
				<task>Linux commands: Pull commented IPv4 hosts from /etc/hosts egrep "^[ \t]*#+[ \t]*([0-9]{1,3}\.){3}[0-9]{1,3}" /etc/hosts</task>
				<task>Linux commands: Pull IPv6 hosts from /etc/hosts egrep "(([:xdigit:]{0,4})\:?\:{1}){0,7}\:?\:{1}([:xdigit:]{0,4})?" /etc/hosts</task>
				<task>Linux commands: Pull hostnames from known_hosts files for any user home you have access to read. for i in $(awk -F: '{print $6}' /etc/passwd|sort -u); do awk '{print $1}' ${i}/.ssh/known_hosts 2> /dev/null;done|tr ',' '\n'|sort -u testhost testhost3 testhost4 ipv6test prodhost</task>
				<task>Linux commands: Show private keys and if they are encrypted for i in $(grep "PRIVATE" *|egrep -v "END"|awk -F: '{print $1}'); do print ${i};grep ENCRYPTED ${i};echo;done id_dsa</task>
				<task>Linux commands: Look at the public keys and pull their type. Numerical types are SSH protocol 1. for i in $(ls *.pub);do print ${i};awk '{print $1}' ${i};echo;done id_dsa.pub ssh-dss</task>
				<task>History/Logs - Linux: date, df, iostat, netstat, lsof, ps, top, who, .bash_history and other shell history files syslog</task>
				<task>History/Logs - MySQL: MySQL History, syslog</task>
				<task>History/Logs - Windows: Event Logs, Recent opened files, Browsers, Favorites, stored passwords, stored cookies, browsing history, browser cache files, syslog</task>
				<task>Cleanup: Ensure documented steps of exploitation.</task>
				<task>Cleanup: Remove Test Data, Leave no trace</task>
				<task>Cleanup: Proper archiving and encryption of evidence to be handed back to customer</task>
				<task>Cleanup: Restore database from backup where necessary</task>
			</tasks>
		</section>
		<section>
			<name>Persistence</name>
			<tasks>
				<task>Autostart Malware</task>
				<task>Reverse Connections</task>
				<task>Rootkits: User Mode, Kernel Based</task>
				<task>C+C medium (http, dns, tcp, icmp)</task>
				<task>Backdoors</task>
				<task>Implants</task>
				<task>VPN with credentials</task>
			</tasks>
		</section>
	</sections>
</methodology>